apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  labels:
    db: postgresql
    provider: aws
  name: aws-postgresql
spec:
  compositeTypeRef:
    apiVersion: devopstoolkit.live/v1beta1
    kind: SQL
  mode: Pipeline
  pipeline:
  - step: main
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          # import models.io.upbound.aws.ec2.v1beta1 as ec2v1beta1
          # import models.io.upbound.aws.rds.v1beta1 as rdsv1beta1
          # import models.io.upbound.aws.rds.v1beta2 as rdsv1beta2
          import models.io.crossplane.kubernetes.v1alpha2 as k8sv1alpha2

          oxr = option("params").oxr
          ocds = option("params").ocds

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          _region = "us-east-1"
          if oxr.spec?.region:
              _region = oxr.spec.region

          _metadata = lambda resourceName: str -> any {
              {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/composition-resource-name" = resourceName
                  }
              }
          }

          _items = [
              {
                  apiVersion = "ec2.aws.m.upbound.io/v1beta1"
                  kind = "InternetGateway"
                  metadata = _metadata("gateway")
                  spec.forProvider = {
                      region = _region
                      vpcIdSelector.matchControllerRef = True
                  }
              },
              {
                  apiVersion = "ec2.aws.m.upbound.io/v1beta1"
                  kind = "MainRouteTableAssociation"
                  metadata = _metadata("mainRouteTableAssociation")
                  spec.forProvider = {
                      region = _region
                      routeTableIdSelector.matchControllerRef = True
                      vpcIdSelector.matchControllerRef = True
                  }
              }, {
                  apiVersion = "ec2.aws.m.upbound.io/v1beta1"
                  kind = "RouteTable"
                  metadata = _metadata("routeTable")
                  spec.forProvider = {
                      region = _region
                      vpcIdSelector.matchControllerRef = True
                  }
              }, {
                  apiVersion = "ec2.aws.m.upbound.io/v1beta2"
                  kind = "Route"
                  metadata = _metadata("route")
                  spec.forProvider = {
                      region = _region
                      routeTableIdSelector.matchControllerRef = True
                      destinationCidrBlock = "0.0.0.0/0"
                      gatewayIdSelector.matchControllerRef = True
                  }
              }, {
                  apiVersion = "ec2.aws.m.upbound.io/v1beta1"
                  kind = "SecurityGroupRule"
                  metadata = _metadata("securityGroupRule")
                  spec.forProvider = {
                      region = _region
                      description = "I am too lazy to write descriptions"
                      type = "ingress"
                      fromPort = 5432
                      toPort = 5432
                      protocol = "tcp"
                      cidrBlocks = ["0.0.0.0/0"]
                      securityGroupIdSelector.matchControllerRef = True
                  }
              }, {
                  apiVersion = "ec2.aws.m.upbound.io/v1beta1"
                  kind = "SecurityGroup"
                  metadata = _metadata("securityGroup")
                  spec.forProvider = {
                      region = _region
                      description = "I am too lazy to write descriptions"
                      vpcIdSelector.matchControllerRef = True
                  }
              }, {
                  apiVersion = "ec2.aws.m.upbound.io/v1beta1"
                  kind = "VPC"
                  metadata = _metadata("vpc")
                  spec.forProvider = {
                      region = _region
                      cidrBlock = "11.0.0.0/16"
                      enableDnsSupport = True
                      enableDnsHostnames = True
                  }
              }, {
                  apiVersion = "rds.aws.m.upbound.io/v1beta1"
                  kind = "SubnetGroup"
                  metadata = _metadata("subnetgroup")
                  spec.forProvider = {
                      region = _region
                      description = "I'm too lazy to write a good description"
                      subnetIdSelector.matchControllerRef = True
                  }
              }, {
                  apiVersion = "rds.aws.m.upbound.io/v1beta3"
                  kind = "Instance"
                  metadata = _metadata("rdsinstance")
                  spec.forProvider = {
                      region = _region
                      dbSubnetGroupNameSelector.matchControllerRef = True
                      vpcSecurityGroupIdSelector.matchControllerRef = True
                      username = "masteruser"
                      engine = "postgres"
                      skipFinalSnapshot = True
                      publiclyAccessible = True
                      allocatedStorage = 200
                      passwordSecretRef = {
                          name = _name + "-password"
                          key = "password"
                          namespace = _namespace
                      }
                      storageEncrypted = True
                      identifier = _name
                      if oxr.spec.size == "small":
                          instanceClass = "db.m5.large"
                      elif oxr.spec.size == "medium":
                          instanceClass = "db.m5.2xlarge"
                      else:
                          instanceClass = "db.m5.8xlarge"
                      engineVersion = oxr.spec.version
                  }
              },
              k8sv1alpha2.Object {
                  metadata = {
                      name = _name + "-secret"
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "krm.kcl.dev/composition-resource-name" = "sql-secret"
                      }
                  }
                  spec = {
                      references = [{
                          patchesFrom = {
                              apiVersion = "rds.aws.upbound.io/v1beta1"
                              kind = "Instance"
                              name = _name
                              namespace = "crossplane-system"
                              fieldPath = "spec.forProvider.username"
                          }
                          toFieldPath = "stringData.username"
                      }, {
                          patchesFrom = {
                              apiVersion = "v1"
                              kind = "Secret"
                              name = _name + "-password"
                              namespace = _namespace
                              fieldPath = "data.password"
                          }
                          toFieldPath = "data.password"
                      }, {
                          patchesFrom = {
                              apiVersion = "rds.aws.upbound.io/v1beta1"
                              kind = "Instance"
                              name = _name
                              namespace = "crossplane-system"
                              fieldPath = "status.atProvider.address"
                          }
                          toFieldPath = "stringData.endpoint"
                      }]
                      forProvider.manifest = {
                          apiVersion = "v1"
                          kind = "Secret"
                          metadata = {
                              name = _name
                              namespace = _namespace
                          }
                          data.port = "NTQzMg=="
                      }
                      providerConfigRef.name = _name + "-sql"
                  }
              }, {
                  **oxr
                  if "rdsinstance" in ocds:
                      status.address = ocds["rdsinstance"].Resource.status.atProvider.address
              }
          ]

          _zoneList = [
              { zone = "a", cidrBlock = "11.0.0.0/24" },
              { zone = "b", cidrBlock = "11.0.1.0/24"  },
              { zone = "c", cidrBlock = "11.0.2.0/24"  }
          ]

          _routeTableAssociations = [
              {
                  apiVersion = "ec2.aws.m.upbound.io/v1beta1"
                  kind = "RouteTableAssociation"
                  metadata = {
                      name = _name + "-1" + _data.zone
                      annotations = {
                          "krm.kcl.dev/composition-resource-name" = "routeTableAssociation1" + _data.zone
                      }
                  }
                  spec.forProvider = {
                      region = _region
                      routeTableIdSelector.matchControllerRef = True
                      subnetIdSelector = {
                          matchControllerRef = True
                          matchLabels.zone = _region + _data.zone
                      }
                  }
              } for _data in _zoneList
          ]

          _subnets = [
              {
                  apiVersion = "ec2.aws.m.upbound.io/v1beta1"
                  kind = "Subnet"
                  metadata = {
                      name = _name + "-" + _data.zone
                      annotations = {
                          "krm.kcl.dev/composition-resource-name" = "subnet-" + _data.zone
                      }
                      labels = {
                          zone = _region + _data.zone
                      }
                  }
                  spec.forProvider = {
                      region = _region
                      availabilityZone = _region + _data.zone
                      cidrBlock = _data.cidrBlock
                      vpcIdSelector.matchControllerRef = True
                  }
              } for _data in _zoneList
          ]

          items = _items + _routeTableAssociations + _subnets
  - step: common
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          schema providerConfig:
              _apiVersion: str
              _suffix: str
              apiVersion = _apiVersion
              kind = "ProviderConfig"
              metadata = {
                  name = _name + "-sql"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = _name + "-provider-config-" + _suffix
                  }
              }
              spec = {
                  credentials.source = "InjectedIdentity"
              }

          _items = [
              providerConfig {
                  _apiVersion = "kubernetes.crossplane.io/v1alpha1"
                  _suffix = "kubernetes"
          }, {
              apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
              kind = "ProviderConfig"
              metadata = {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-config"
                      "crossplane.io/external-name" = "default"
                  }
              }
              spec = {
                  credentials = {
                    source = "PostgreSQLConnectionSecret"
                    connectionSecretRef = {
                      name = _name
                      namespace = _namespace
                    }
                  }
                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                      defaultDatabase = "defaultdb"
                  sslMode = "require"
              }
          }]

          if oxr.spec?.databases:
              _items += [{
                  apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
                  kind = "Database"
                  metadata = {
                      name = _name + "-" + _database
                      annotations = {
                          "crossplane.io/external-name" = _database
                          "krm.kcl.dev/composition-resource-name" = _name + "-" + _database
                      }
                  }
                  spec = {
                      providerConfigRef.name = _name
                      forProvider = {}
                      deletionPolicy = "Orphan"
                  }
              } for _database in oxr.spec.databases ]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pullRootPasswordKey:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name + "-password"
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull"
                      }
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = oxr.spec.secrets.pullRootPasswordKey
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name + "-password"
                      }
                  }
              }]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pushToStore:
              _endpoint = """\
          {
            "endpoint": "{{ .endpoint }}",
            "port": "{{ .port }}",
            "username": "{{ .username }}",
            "password": "{{ .password }}",
            """
              _conns = [ "\"conn-{}\": \"host=[[ .endpoint ]] user=[[ .username ]] password=[[ .password ]] port=[[ .port ]] connect_timeout=10 database={}\"".format(_db, _db).replace("[[", "{{").replace("]]", "}}") for _db in oxr.spec.databases ]
              _endpoint += ",\n  ".join(_conns)
              _endpoint += """
          }
          """
              _items += [{
                  apiVersion = "external-secrets.io/v1alpha1"
                  kind = "PushSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-push-store"
                      }
                  }
                  spec = {
                      refreshInterval = "1h"
                      secretStoreRefs = [{
                          name = oxr.spec.secrets.storeName
                          kind = "ClusterSecretStore"
                      }]
                      selector.secret.name = _name
                      template.data.endpoint = _endpoint
                      data = [{
                          match = {
                              secretKey = "endpoint"
                              remoteRef.remoteKey = _name
                          }
                      }]
                      deletionPolicy = "Delete"
                  }
              }]

          if oxr.spec.schemas:
              _items += [{
                  apiVersion = "db.atlasgo.io/v1alpha1"
                  kind = "AtlasSchema"
                  metadata = {
                      name = _name + "-" + _schema.database
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-schema-" + _schema.database
                      }
                  }
                  spec = {
                      credentials = {
                          scheme = "postgres"
                          hostFrom.secretKeyRef = {
                              key = "endpoint"
                              name = _name
                          }
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                              port = 11569
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider != "upcloud":
                              port = 5432
                          userFrom.secretKeyRef = {
                              key = "username"
                              name = _name
                          }
                          passwordFrom.secretKeyRef = {
                              key = "password"
                              name = _name
                          }
                          database = _schema.database
                          parameters.sslmode = "require"
                      }
                      schema.sql = _schema.sql
                  }
              } for _schema in oxr.spec.schemas ]

          if oxr.spec.secrets?.pullToCluster:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull-cluster"
                      }
                      namespace = oxr.spec.secrets.pullToClusterNamespace
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = _name
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name
                      }
                  }
              }]

          items = _items
  - step: statuses
    functionRef:
      name: crossplane-contrib-function-status-transformer
    input:
      apiVersion: function-status-transformer.fn.crossplane.io/v1beta1
      kind: StatusTransformation
      statusConditionHooks:
      - matchers:
        - resources:
          - name: vpc
          conditions:
          - type: Synced
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'True'
            message: So far so good
      - matchers:
        - resources:
          - name: vpc
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: (.*)cannot get referenced ProviderConfig(.*)
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: ProviderConfig is missing. Contact service owner.
      - matchers:
        - resources:
          - name: vpc
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: '(.*)lookup sts.(?P<Region>.*).amazonaws.com on (.*): no such host(.*)'
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: Selected region {{ .Region }} is not available. Double check the `spec.region` value.
  - step: automatically-detect-ready-composed-resources
    functionRef:
      name: crossplane-contrib-function-auto-ready
  writeConnectionSecretsToNamespace: crossplane-system
---
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  labels:
    db: postgresql
    provider: aws-ack
  name: aws-ack-postgresql
spec:
  compositeTypeRef:
    apiVersion: devopstoolkit.live/v1beta1
    kind: SQL
  mode: Pipeline
  pipeline:
  - step: main
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          import models.io.crossplane.kubernetes.v1alpha2 as k8sv1alpha2

          oxr = option("params").oxr
          ocds = option("params").ocds

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          _region = "us-east-1"
          if oxr.spec?.region:
              _region = oxr.spec.region

          _metadata = lambda resourceName: str -> any {
              _metadataSuffix(resourceName, "")
          }
          _metadataSuffix = lambda resourceName: str, nameSuffix: str -> any {
              {
                  _fullName = _name
                  if nameSuffix:
                      _fullName = "{}-{}".format(_name, nameSuffix)
                  name = _fullName
                  annotations = {
                      "krm.kcl.dev/composition-resource-name" = resourceName
                      "services.k8s.aws/region" = _region
                  }
              }
          }
          _tags = [{key = "name", value = _name}]

          _zoneList = [
              { zone = "a", cidrBlock = "11.0.0.0/24" },
              { zone = "b", cidrBlock = "11.0.1.0/24"  },
              { zone = "c", cidrBlock = "11.0.2.0/24"  }
          ]

          _items = [
              {
                  apiVersion = "ec2.services.k8s.aws/v1alpha1"
                  kind = "VPC"
                  metadata =_metadata("vpc")
                  spec = {
                      cidrBlocks = ["11.0.0.0/16"]
                      enableDNSSupport = True
                      enableDNSHostnames = True
                      tags = _tags
                  }
              }, {
                  apiVersion = "ec2.services.k8s.aws/v1alpha1"
                  kind = "InternetGateway"
                  metadata =_metadata("internetgateway")
                  spec = {
                      vpcRef.from.name = _name
                      tags = _tags
                  }
              }, {
                  apiVersion = "ec2.services.k8s.aws/v1alpha1"
                  kind = "RouteTable"
                  metadata = _metadata("routetable")
                  spec = {
                      vpcRef.from.name = _name
                      routes = [{
                          destinationCIDRBlock = "0.0.0.0/0"
                          gatewayRef.from.name = _name
                      }]
                      tags = _tags
                  }
              }, {
                  apiVersion = "ec2.services.k8s.aws/v1alpha1"
                  kind = "SecurityGroup"
                  metadata = _metadata("securitygroup")
                  spec = {
                      name = _name
                      description = "I am too lazy to write descriptions"
                      vpcRef.from.name = _name
                      ingressRules = [{
                          fromPort = 5432
                          toPort = 5432
                          ipProtocol = "tcp"
                          ipRanges = [{
                              cidrIP = "0.0.0.0/0"
                              description = "I am too lazy to write descriptions"
                          }]
                      }]
                      tags = _tags
                  }
              }, {
                  apiVersion = "rds.services.k8s.aws/v1alpha1"
                  kind = "DBSubnetGroup"
                  metadata = _metadata("dbsubnetgroup")
                  spec = {
                      name = _name
                      description = "I am too lazy to write descriptions"
                      subnetRefs = [
                          {from.name = "{}-{}".format(_name, _data.zone)} for _data in _zoneList
                      ]
                  }
              }, {
                  apiVersion = "rds.services.k8s.aws/v1alpha1"
                  kind = "DBInstance"
                  metadata = _metadata("dbinstance")
                  spec = {
                      dbSubnetGroupRef.from.name = _name
                      vpcSecurityGroupRefs = [{from.name = _name}]
                      masterUsername = "masteruser"
                      engine = "postgres"
                      # skipFinalSnapshot: true
                      publiclyAccessible = True
                      allocatedStorage = 200
                      masterUserPassword = {
                          key = "password"
                          name = "{}-password".format(_name)
                      }
                      storageEncrypted = True
                      dbInstanceIdentifier = _name
                      if oxr.spec.size == "small":
                          dbInstanceClass = "db.m5.large"
                      elif oxr.spec.size == "medium":
                          dbInstanceClass = "db.m5.2xlarge"
                      else:
                          dbInstanceClass = "db.m5.8xlarge"
                      engineVersion = oxr.spec.version
                  }
              },
              k8sv1alpha2.Object {
                  metadata = {
                      name = "{}-secret".format(_name)
                      annotations = {
                          "krm.kcl.dev/ready": "True"
                          "krm.kcl.dev/composition-resource-name" = "sql-secret"
                      }
                  }
                  spec = {
                      references = [{
                          patchesFrom = {
                              apiVersion = "rds.services.k8s.aws/v1alpha1"
                              kind = "DBInstance"
                              name = _name
                              namespace = _namespace
                              fieldPath = "spec.masterUsername"
                          }
                          toFieldPath = "stringData.username"
                      }, {
                          patchesFrom = {
                              apiVersion = "v1"
                              kind = "Secret"
                              name = "{}-password".format(_name)
                              namespace = _namespace
                              fieldPath = "data.password"
                          }
                          toFieldPath = "data.password"
                      }, {
                          patchesFrom = {
                              apiVersion = "rds.services.k8s.aws/v1alpha1"
                              kind = "DBInstance"
                              name = _name
                              namespace = _namespace
                              fieldPath = "status.endpoint.address"
                          }
                          toFieldPath = "stringData.endpoint"
                      }]
                      forProvider.manifest = {
                          apiVersion = "v1"
                          kind = "Secret"
                          metadata = {
                              name = _name
                              namespace = _namespace
                          }
                          data.port = "NTQzMg=="
                      }
                      providerConfigRef.name = _name + "-sql"
                  }
              }
          ]

          _subnets = [
              {
                  apiVersion = "ec2.services.k8s.aws/v1alpha1"
                  kind = "Subnet"
                  metadata = _metadataSuffix("subnet-{}".format(_data.zone), _data.zone)
                  spec = {
                      availabilityZone: "{}{}".format(_region, _data.zone)
                      cidrBlock: _data.cidrBlock
                      vpcRef.from.name = _name
                      routeTableRefs = [{from.name = _name}]
                      tags = [
                      {key = "name", value = _name},
                      {key: "zone", value: "{}{}".format(_region, _data.zone)}]
                  }
              } for _data in _zoneList
          ]

          items = _items + _subnets
  - step: common
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          schema providerConfig:
              _apiVersion: str
              _suffix: str
              apiVersion = _apiVersion
              kind = "ProviderConfig"
              metadata = {
                  name = _name + "-sql"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = _name + "-provider-config-" + _suffix
                  }
              }
              spec = {
                  credentials.source = "InjectedIdentity"
              }

          _items = [
              providerConfig {
                  _apiVersion = "kubernetes.crossplane.io/v1alpha1"
                  _suffix = "kubernetes"
          }, {
              apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
              kind = "ProviderConfig"
              metadata = {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-config"
                      "crossplane.io/external-name" = "default"
                  }
              }
              spec = {
                  credentials = {
                    source = "PostgreSQLConnectionSecret"
                    connectionSecretRef = {
                      name = _name
                      namespace = _namespace
                    }
                  }
                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                      defaultDatabase = "defaultdb"
                  sslMode = "require"
              }
          }]

          if oxr.spec?.databases:
              _items += [{
                  apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
                  kind = "Database"
                  metadata = {
                      name = _name + "-" + _database
                      annotations = {
                          "crossplane.io/external-name" = _database
                          "krm.kcl.dev/composition-resource-name" = _name + "-" + _database
                      }
                  }
                  spec = {
                      providerConfigRef.name = _name
                      forProvider = {}
                      deletionPolicy = "Orphan"
                  }
              } for _database in oxr.spec.databases ]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pullRootPasswordKey:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name + "-password"
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull"
                      }
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = oxr.spec.secrets.pullRootPasswordKey
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name + "-password"
                      }
                  }
              }]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pushToStore:
              _endpoint = """\
          {
            "endpoint": "{{ .endpoint }}",
            "port": "{{ .port }}",
            "username": "{{ .username }}",
            "password": "{{ .password }}",
            """
              _conns = [ "\"conn-{}\": \"host=[[ .endpoint ]] user=[[ .username ]] password=[[ .password ]] port=[[ .port ]] connect_timeout=10 database={}\"".format(_db, _db).replace("[[", "{{").replace("]]", "}}") for _db in oxr.spec.databases ]
              _endpoint += ",\n  ".join(_conns)
              _endpoint += """
          }
          """
              _items += [{
                  apiVersion = "external-secrets.io/v1alpha1"
                  kind = "PushSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-push-store"
                      }
                  }
                  spec = {
                      refreshInterval = "1h"
                      secretStoreRefs = [{
                          name = oxr.spec.secrets.storeName
                          kind = "ClusterSecretStore"
                      }]
                      selector.secret.name = _name
                      template.data.endpoint = _endpoint
                      data = [{
                          match = {
                              secretKey = "endpoint"
                              remoteRef.remoteKey = _name
                          }
                      }]
                      deletionPolicy = "Delete"
                  }
              }]

          if oxr.spec.schemas:
              _items += [{
                  apiVersion = "db.atlasgo.io/v1alpha1"
                  kind = "AtlasSchema"
                  metadata = {
                      name = _name + "-" + _schema.database
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-schema-" + _schema.database
                      }
                  }
                  spec = {
                      credentials = {
                          scheme = "postgres"
                          hostFrom.secretKeyRef = {
                              key = "endpoint"
                              name = _name
                          }
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                              port = 11569
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider != "upcloud":
                              port = 5432
                          userFrom.secretKeyRef = {
                              key = "username"
                              name = _name
                          }
                          passwordFrom.secretKeyRef = {
                              key = "password"
                              name = _name
                          }
                          database = _schema.database
                          parameters.sslmode = "require"
                      }
                      schema.sql = _schema.sql
                  }
              } for _schema in oxr.spec.schemas ]

          if oxr.spec.secrets?.pullToCluster:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull-cluster"
                      }
                      namespace = oxr.spec.secrets.pullToClusterNamespace
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = _name
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name
                      }
                  }
              }]

          items = _items
  - step: automatically-detect-ready-composed-resources
    functionRef:
      name: crossplane-contrib-function-auto-ready
  writeConnectionSecretsToNamespace: crossplane-system
---
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  labels:
    db: postgresql
    provider: azure
  name: azure-postgresql
spec:
  compositeTypeRef:
    apiVersion: devopstoolkit.live/v1beta1
    kind: SQL
  mode: Pipeline
  pipeline:
  - step: main
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr
          ocds = option("params").ocds

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          _region = "eastus"
          if oxr.spec?.region:
              _region = oxr.spec.region

          _metadata = lambda resourceName: str -> any {
              {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/composition-resource-name" = resourceName
                  }
              }
          }

          _items = [{
              apiVersion = "azure.upbound.io/v1beta1"
              kind = "ResourceGroup"
              metadata = _metadata("resourcegroup")
              spec.forProvider.location = _region
          }, {
              apiVersion = "dbforpostgresql.azure.upbound.io/v1beta1"
              kind = "Server"
              metadata = _metadata("server")
              spec = {
                  forProvider = {
                      location = _region
                      version = oxr.spec.version
                      if oxr.spec.size == "small":
                          skuName = "B_Gen5_1"
                      elif oxr.spec.size == "medium":
                          skuName = "GP_Gen5_2"
                      else:
                          skuName = "GP_Gen5_8"
                      resourceGroupNameSelector.matchControllerRef = True
                      storageMb = 5120
                      autoGrowEnabled = True
                      sslEnforcementEnabled = False
                      sslMinimalTlsVersionEnforced = "TLSEnforcementDisabled"
                      administratorLogin = "postgres"
                      administratorLoginPasswordSecretRef = {
                          name = _name + "-password"
                          key = "password"
                          namespace: _namespace
                      }
                      publicNetworkAccessEnabled = True
                  }
                  writeConnectionSecretToRef = {
                      name = _name
                      namespace = _namespace
                  }
              }
          }, {
              apiVersion = "dbforpostgresql.azure.upbound.io/v1beta1"
              kind = "FirewallRule"
              metadata = _metadata("firewall-rule")
              spec.forProvider = {
                  startIpAddress = "0.0.0.0"
                  endIpAddress = "255.255.255.255"
                  resourceGroupNameSelector.matchControllerRef = True
                  serverNameSelector.matchControllerRef = True
              }
          # }, {
          #     apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
          #     kind = "ProviderConfig"
          #     metadata = {
          #         name = _name
          #         annotations = {
          #             "krm.kcl.dev/ready": "True"
          #             "krm.kcl.dev/composition-resource-name" = "sql-config"
          #         }
          #     }
          #     spec = {
          #         credentials = {
          #             source = "PostgreSQLConnectionSecret"
          #             connectionSecretRef = {
          #                 name = _name
          #             }
          #         }
          #         sslMode = "require"
          #     }
          }, {
              **oxr
              if "server" in ocds:
                  status.address = ocds["server"].Resource.status.atProvider.fqdn
          }]

          items = _items
  - step: common
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          schema providerConfig:
              _apiVersion: str
              _suffix: str
              apiVersion = _apiVersion
              kind = "ProviderConfig"
              metadata = {
                  name = _name + "-sql"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = _name + "-provider-config-" + _suffix
                  }
              }
              spec = {
                  credentials.source = "InjectedIdentity"
              }

          _items = [
              providerConfig {
                  _apiVersion = "kubernetes.crossplane.io/v1alpha1"
                  _suffix = "kubernetes"
          }, {
              apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
              kind = "ProviderConfig"
              metadata = {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-config"
                      "crossplane.io/external-name" = "default"
                  }
              }
              spec = {
                  credentials = {
                    source = "PostgreSQLConnectionSecret"
                    connectionSecretRef = {
                      name = _name
                      namespace = _namespace
                    }
                  }
                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                      defaultDatabase = "defaultdb"
                  sslMode = "require"
              }
          }]

          if oxr.spec?.databases:
              _items += [{
                  apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
                  kind = "Database"
                  metadata = {
                      name = _name + "-" + _database
                      annotations = {
                          "crossplane.io/external-name" = _database
                          "krm.kcl.dev/composition-resource-name" = _name + "-" + _database
                      }
                  }
                  spec = {
                      providerConfigRef.name = _name
                      forProvider = {}
                      deletionPolicy = "Orphan"
                  }
              } for _database in oxr.spec.databases ]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pullRootPasswordKey:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name + "-password"
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull"
                      }
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = oxr.spec.secrets.pullRootPasswordKey
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name + "-password"
                      }
                  }
              }]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pushToStore:
              _endpoint = """\
          {
            "endpoint": "{{ .endpoint }}",
            "port": "{{ .port }}",
            "username": "{{ .username }}",
            "password": "{{ .password }}",
            """
              _conns = [ "\"conn-{}\": \"host=[[ .endpoint ]] user=[[ .username ]] password=[[ .password ]] port=[[ .port ]] connect_timeout=10 database={}\"".format(_db, _db).replace("[[", "{{").replace("]]", "}}") for _db in oxr.spec.databases ]
              _endpoint += ",\n  ".join(_conns)
              _endpoint += """
          }
          """
              _items += [{
                  apiVersion = "external-secrets.io/v1alpha1"
                  kind = "PushSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-push-store"
                      }
                  }
                  spec = {
                      refreshInterval = "1h"
                      secretStoreRefs = [{
                          name = oxr.spec.secrets.storeName
                          kind = "ClusterSecretStore"
                      }]
                      selector.secret.name = _name
                      template.data.endpoint = _endpoint
                      data = [{
                          match = {
                              secretKey = "endpoint"
                              remoteRef.remoteKey = _name
                          }
                      }]
                      deletionPolicy = "Delete"
                  }
              }]

          if oxr.spec.schemas:
              _items += [{
                  apiVersion = "db.atlasgo.io/v1alpha1"
                  kind = "AtlasSchema"
                  metadata = {
                      name = _name + "-" + _schema.database
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-schema-" + _schema.database
                      }
                  }
                  spec = {
                      credentials = {
                          scheme = "postgres"
                          hostFrom.secretKeyRef = {
                              key = "endpoint"
                              name = _name
                          }
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                              port = 11569
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider != "upcloud":
                              port = 5432
                          userFrom.secretKeyRef = {
                              key = "username"
                              name = _name
                          }
                          passwordFrom.secretKeyRef = {
                              key = "password"
                              name = _name
                          }
                          database = _schema.database
                          parameters.sslmode = "require"
                      }
                      schema.sql = _schema.sql
                  }
              } for _schema in oxr.spec.schemas ]

          if oxr.spec.secrets?.pullToCluster:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull-cluster"
                      }
                      namespace = oxr.spec.secrets.pullToClusterNamespace
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = _name
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name
                      }
                  }
              }]

          items = _items
  - step: statuses
    functionRef:
      name: crossplane-contrib-function-status-transformer
    input:
      apiVersion: function-status-transformer.fn.crossplane.io/v1beta1
      kind: StatusTransformation
      statusConditionHooks:
      - matchers:
        - resources:
          - name: resourcegroup
          conditions:
          - type: Synced
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'True'
            message: So far so good
      - matchers:
        - resources:
          - name: resourcegroup
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: (.*)cannot get referenced ProviderConfig(.*)
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: ProviderConfig is missing. Contact service owner.
      - matchers:
        - resources:
          - name: resourcegroup
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: (.*)The specified location '(?P<Region>.*)' is invalid(.*)
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: Selected region {{ .Region }} is not available. Double check the `spec.region` value.
      - matchers:
        - resources:
          - name: resourcegroup
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: (.*)The provided location '(?P<Region>.*)' is not available for resource group(.*)
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: Selected region {{ .Region }} is not available. Double check the `spec.region` value.
  - step: automatically-detect-ready-composed-resources
    functionRef:
      name: crossplane-contrib-function-auto-ready
  writeConnectionSecretsToNamespace: crossplane-system
---
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  labels:
    db: postgresql
    provider: azure-aso
  name: azure-aso-postgresql
spec:
  compositeTypeRef:
    apiVersion: devopstoolkit.live/v1beta1
    kind: SQL
  mode: Pipeline
  pipeline:
  - step: main
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr
          ocds = option("params").ocds

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          _region = "eastus"
          if oxr.spec?.region:
              _region = oxr.spec.region

          _metadata = lambda resourceName: str -> any {
              {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/composition-resource-name" = resourceName
                  }
              }
          }

          _items = [{
              apiVersion = "resources.azure.com/v1api20200601"
              kind = "ResourceGroup"
              metadata = _metadata("resourcegroup")
              spec.location = _region
          }, {
              apiVersion = "dbforpostgresql.azure.com/v1api20221201"
              kind = "FlexibleServer"
              metadata = _metadata("server")
              spec = {
                  location = _region
                  version = oxr.spec.version
                  if oxr.spec.size == "small":
                      sku.name = "Standard_D2ds_v4"
                  elif oxr.spec.size == "medium":
                      sku.name = "Standard_D8ds_v4"
                  else:
                      sku.name = "Standard_D32ds_v4"
                  sku.tier = "GeneralPurpose"
                  owner.name = _name
                  storage.storageSizeGB = 128
                  administratorLogin = "postgres"
                  administratorLoginPassword = {
                      name = _name + "-password"
                      key = "password"
                  }
              }
          }, {
              apiVersion = "dbforpostgresql.azure.com/v1api20221201"
              kind = "FlexibleServersFirewallRule"
              metadata = _metadata("firewall-rule")
              spec = {
                  startIpAddress = "0.0.0.0"
                  endIpAddress = "255.255.255.255"
                  owner.name = _name
                  azureName = _name
              }
          }, {
              apiVersion = "kubernetes.crossplane.io/v1alpha2"
              kind = "Object"
              metadata = {
                  name = _name + "-secret"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-secret"
                  }
              }
              spec = {
                  references = [{
                      patchesFrom = {
                          apiVersion = "dbforpostgresql.azure.com/v1api20221201"
                          kind = "FlexibleServer"
                          name = _name
                          namespace = _namespace
                          fieldPath = "status.administratorLogin"
                      }
                      toFieldPath = "stringData.username"
                  }, {
                      patchesFrom = {
                          apiVersion = "v1"
                          kind = "Secret"
                          name = _name + "-password"
                          namespace = _namespace
                          fieldPath = "data.password"
                      }
                      toFieldPath = "data.password"
                  }, {
                      patchesFrom = {
                          apiVersion = "dbforpostgresql.azure.com/v1api20221201"
                          kind = "FlexibleServer"
                          name = _name
                          namespace = _namespace
                          fieldPath = "status.fullyQualifiedDomainName"
                      }
                      toFieldPath = "stringData.endpoint"
                  }]
                  forProvider.manifest = {
                      apiVersion = "v1"
                      kind = "Secret"
                      metadata = {
                          name = _name
                          namespace = _namespace
                      }
                      data.port = "NTQzMg=="
                  }
                  providerConfigRef.name = _name + "-sql"
              }
          }, {
              **oxr
              if "server" in ocds:
                  status.address = ocds["server"].Resource.status.fullyQualifiedDomainName
          }]

          items = _items
  - step: common
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          schema providerConfig:
              _apiVersion: str
              _suffix: str
              apiVersion = _apiVersion
              kind = "ProviderConfig"
              metadata = {
                  name = _name + "-sql"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = _name + "-provider-config-" + _suffix
                  }
              }
              spec = {
                  credentials.source = "InjectedIdentity"
              }

          _items = [
              providerConfig {
                  _apiVersion = "kubernetes.crossplane.io/v1alpha1"
                  _suffix = "kubernetes"
          }, {
              apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
              kind = "ProviderConfig"
              metadata = {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-config"
                      "crossplane.io/external-name" = "default"
                  }
              }
              spec = {
                  credentials = {
                    source = "PostgreSQLConnectionSecret"
                    connectionSecretRef = {
                      name = _name
                      namespace = _namespace
                    }
                  }
                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                      defaultDatabase = "defaultdb"
                  sslMode = "require"
              }
          }]

          if oxr.spec?.databases:
              _items += [{
                  apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
                  kind = "Database"
                  metadata = {
                      name = _name + "-" + _database
                      annotations = {
                          "crossplane.io/external-name" = _database
                          "krm.kcl.dev/composition-resource-name" = _name + "-" + _database
                      }
                  }
                  spec = {
                      providerConfigRef.name = _name
                      forProvider = {}
                      deletionPolicy = "Orphan"
                  }
              } for _database in oxr.spec.databases ]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pullRootPasswordKey:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name + "-password"
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull"
                      }
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = oxr.spec.secrets.pullRootPasswordKey
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name + "-password"
                      }
                  }
              }]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pushToStore:
              _endpoint = """\
          {
            "endpoint": "{{ .endpoint }}",
            "port": "{{ .port }}",
            "username": "{{ .username }}",
            "password": "{{ .password }}",
            """
              _conns = [ "\"conn-{}\": \"host=[[ .endpoint ]] user=[[ .username ]] password=[[ .password ]] port=[[ .port ]] connect_timeout=10 database={}\"".format(_db, _db).replace("[[", "{{").replace("]]", "}}") for _db in oxr.spec.databases ]
              _endpoint += ",\n  ".join(_conns)
              _endpoint += """
          }
          """
              _items += [{
                  apiVersion = "external-secrets.io/v1alpha1"
                  kind = "PushSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-push-store"
                      }
                  }
                  spec = {
                      refreshInterval = "1h"
                      secretStoreRefs = [{
                          name = oxr.spec.secrets.storeName
                          kind = "ClusterSecretStore"
                      }]
                      selector.secret.name = _name
                      template.data.endpoint = _endpoint
                      data = [{
                          match = {
                              secretKey = "endpoint"
                              remoteRef.remoteKey = _name
                          }
                      }]
                      deletionPolicy = "Delete"
                  }
              }]

          if oxr.spec.schemas:
              _items += [{
                  apiVersion = "db.atlasgo.io/v1alpha1"
                  kind = "AtlasSchema"
                  metadata = {
                      name = _name + "-" + _schema.database
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-schema-" + _schema.database
                      }
                  }
                  spec = {
                      credentials = {
                          scheme = "postgres"
                          hostFrom.secretKeyRef = {
                              key = "endpoint"
                              name = _name
                          }
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                              port = 11569
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider != "upcloud":
                              port = 5432
                          userFrom.secretKeyRef = {
                              key = "username"
                              name = _name
                          }
                          passwordFrom.secretKeyRef = {
                              key = "password"
                              name = _name
                          }
                          database = _schema.database
                          parameters.sslmode = "require"
                      }
                      schema.sql = _schema.sql
                  }
              } for _schema in oxr.spec.schemas ]

          if oxr.spec.secrets?.pullToCluster:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull-cluster"
                      }
                      namespace = oxr.spec.secrets.pullToClusterNamespace
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = _name
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name
                      }
                  }
              }]

          items = _items
  - step: automatically-detect-ready-composed-resources
    functionRef:
      name: crossplane-contrib-function-auto-ready
  writeConnectionSecretsToNamespace: crossplane-system
---
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  labels:
    db: postgresql
    provider: google
  name: google-postgresql
spec:
  compositeTypeRef:
    apiVersion: devopstoolkit.live/v1beta1
    kind: SQL
  mode: Pipeline
  pipeline:
  - step: main
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr
          ocds = option("params").ocds

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          _region = "us-east1"
          if oxr.spec?.region:
              _region = oxr.spec.region

          _metadata = lambda resourceName: str -> any {
              {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/composition-resource-name" = resourceName
                  }
              }
          }

          _items = [{
              apiVersion = "sql.gcp.upbound.io/v1beta1"
              kind = "DatabaseInstance"
              metadata = _metadata("databaseinstance")
              spec = {
                  forProvider = {
                      region = _region
                      databaseVersion = "POSTGRES_" + oxr.spec.version
                      rootPasswordSecretRef = {
                          name = _name + "-password"
                          key = "password"
                          namespace = _namespace
                      }
                      settings = [{
                          if oxr.spec.size == "small":
                              tier = "db-custom-1-3840"
                          elif oxr.spec.size == "medium":
                              tier = "db-custom-16-61440"
                          else:
                              tier = "db-custom-64-245760"
                          availabilityType = "REGIONAL"
                          backupConfiguration = [{
                              enabled = True
                              binaryLogEnabled = False
                          }]
                          ipConfiguration = [{
                              ipv4Enabled = True
                              authorizedNetworks = [{
                                  name = "all"
                                  value = "0.0.0.0/0"
                              }]
                          }]
                      }]
                      deletionProtection = False
                  }
              }
          }, {
              apiVersion = "sql.gcp.upbound.io/v1beta1"
              kind = "User"
              metadata = _metadata("user")
              spec = {
                  deletionPolicy = "Orphan"
                  forProvider = {
                      passwordSecretRef = {
                          key = "password"
                          name = _name + "-password"
                          namespace = _namespace
                      }
                      instanceSelector.matchControllerRef = True
                  }
              }
          }, {
              apiVersion = "kubernetes.crossplane.io/v1alpha2"
              kind = "Object"
              metadata = {
                  name = _name + "-secret"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-secret"
                  }
              }
              spec = {
                  references = [{
                      patchesFrom = {
                          apiVersion = "sql.gcp.upbound.io/v1beta1"
                          kind = "User"
                          name = _name
                          namespace = "crossplane-system"
                          fieldPath = "metadata.name"
                      }
                      toFieldPath = "stringData.username"
                  }, {
                      patchesFrom = {
                          apiVersion = "v1"
                          kind = "Secret"
                          name = _name + "-password"
                          namespace = _namespace
                          fieldPath = "data.password"
                      }
                      toFieldPath = "data.password"
                  }, {
                      patchesFrom = {
                          apiVersion = "sql.gcp.upbound.io/v1beta1"
                          kind = "DatabaseInstance"
                          name = _name
                          namespace = "crossplane-system"
                          fieldPath = "status.atProvider.publicIpAddress"
                      }
                      toFieldPath = "stringData.endpoint"
                  }]
                  forProvider.manifest = {
                      apiVersion = "v1"
                      kind = "Secret"
                      metadata = {
                          name = _name
                          namespace = _namespace
                      }
                      data.port = "NTQzMg=="
                  }
                  providerConfigRef.name = _name + "-sql"
              }
          }, {
              **oxr
              if "databaseinstance" in ocds:
                  status.address = ocds["databaseinstance"].Resource.status.atProvider.publicIpAddress
          }]

          items = _items
  - step: common
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          schema providerConfig:
              _apiVersion: str
              _suffix: str
              apiVersion = _apiVersion
              kind = "ProviderConfig"
              metadata = {
                  name = _name + "-sql"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = _name + "-provider-config-" + _suffix
                  }
              }
              spec = {
                  credentials.source = "InjectedIdentity"
              }

          _items = [
              providerConfig {
                  _apiVersion = "kubernetes.crossplane.io/v1alpha1"
                  _suffix = "kubernetes"
          }, {
              apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
              kind = "ProviderConfig"
              metadata = {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-config"
                      "crossplane.io/external-name" = "default"
                  }
              }
              spec = {
                  credentials = {
                    source = "PostgreSQLConnectionSecret"
                    connectionSecretRef = {
                      name = _name
                      namespace = _namespace
                    }
                  }
                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                      defaultDatabase = "defaultdb"
                  sslMode = "require"
              }
          }]

          if oxr.spec?.databases:
              _items += [{
                  apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
                  kind = "Database"
                  metadata = {
                      name = _name + "-" + _database
                      annotations = {
                          "crossplane.io/external-name" = _database
                          "krm.kcl.dev/composition-resource-name" = _name + "-" + _database
                      }
                  }
                  spec = {
                      providerConfigRef.name = _name
                      forProvider = {}
                      deletionPolicy = "Orphan"
                  }
              } for _database in oxr.spec.databases ]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pullRootPasswordKey:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name + "-password"
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull"
                      }
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = oxr.spec.secrets.pullRootPasswordKey
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name + "-password"
                      }
                  }
              }]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pushToStore:
              _endpoint = """\
          {
            "endpoint": "{{ .endpoint }}",
            "port": "{{ .port }}",
            "username": "{{ .username }}",
            "password": "{{ .password }}",
            """
              _conns = [ "\"conn-{}\": \"host=[[ .endpoint ]] user=[[ .username ]] password=[[ .password ]] port=[[ .port ]] connect_timeout=10 database={}\"".format(_db, _db).replace("[[", "{{").replace("]]", "}}") for _db in oxr.spec.databases ]
              _endpoint += ",\n  ".join(_conns)
              _endpoint += """
          }
          """
              _items += [{
                  apiVersion = "external-secrets.io/v1alpha1"
                  kind = "PushSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-push-store"
                      }
                  }
                  spec = {
                      refreshInterval = "1h"
                      secretStoreRefs = [{
                          name = oxr.spec.secrets.storeName
                          kind = "ClusterSecretStore"
                      }]
                      selector.secret.name = _name
                      template.data.endpoint = _endpoint
                      data = [{
                          match = {
                              secretKey = "endpoint"
                              remoteRef.remoteKey = _name
                          }
                      }]
                      deletionPolicy = "Delete"
                  }
              }]

          if oxr.spec.schemas:
              _items += [{
                  apiVersion = "db.atlasgo.io/v1alpha1"
                  kind = "AtlasSchema"
                  metadata = {
                      name = _name + "-" + _schema.database
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-schema-" + _schema.database
                      }
                  }
                  spec = {
                      credentials = {
                          scheme = "postgres"
                          hostFrom.secretKeyRef = {
                              key = "endpoint"
                              name = _name
                          }
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                              port = 11569
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider != "upcloud":
                              port = 5432
                          userFrom.secretKeyRef = {
                              key = "username"
                              name = _name
                          }
                          passwordFrom.secretKeyRef = {
                              key = "password"
                              name = _name
                          }
                          database = _schema.database
                          parameters.sslmode = "require"
                      }
                      schema.sql = _schema.sql
                  }
              } for _schema in oxr.spec.schemas ]

          if oxr.spec.secrets?.pullToCluster:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull-cluster"
                      }
                      namespace = oxr.spec.secrets.pullToClusterNamespace
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = _name
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name
                      }
                  }
              }]

          items = _items
  - step: statuses
    functionRef:
      name: crossplane-contrib-function-status-transformer
    input:
      apiVersion: function-status-transformer.fn.crossplane.io/v1beta1
      kind: StatusTransformation
      statusConditionHooks:
      - matchers:
        - resources:
          - name: databaseinstance
          conditions:
          - type: Synced
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'True'
            message: So far so good
      - matchers:
        - resources:
          - name: databaseinstance
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: (.*)cannot get referenced ProviderConfig(.*)
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: ProviderConfig is missing. Contact service owner.
      - matchers:
        - resources:
          - name: databaseinstance
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: '(.*)Invalid value for region: (?P<Region>.*)., invalid(.*)'
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: Selected region {{ .Region }} is not available. Double check the `spec.region` value.
  - step: automatically-detect-ready-composed-resources
    functionRef:
      name: crossplane-contrib-function-auto-ready
  writeConnectionSecretsToNamespace: crossplane-system
---
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  labels:
    db: postgresql
    provider: local
  name: local-postgresql
spec:
  compositeTypeRef:
    apiVersion: devopstoolkit.live/v1beta1
    kind: SQL
  mode: Pipeline
  pipeline:
  - step: main
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr
          ocds = option("params").ocds

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace

          _metadata = lambda resourceName: str -> any {
              {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/composition-resource-name" = resourceName
                  }
              }
          }

          _items = [{
              apiVersion = "postgresql.cnpg.io/v1"
              kind = "Cluster"
              metadata = _metadata("cluster")
              spec = {
                  if oxr.spec.size == "small":
                      instances = 1
                      storage.size = "1Gi"
                  elif oxr.spec.size == "medium":
                      instances = 3
                      storage.size = "3Gi"
                  else:
                      instances = 6
                      storage.size = "6Gi"
              }
          }, {
              apiVersion = "kubernetes.crossplane.io/v1alpha2"
              kind = "Object"
              metadata = {
                  name = _name + "-secret"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-secret"
                  }
              }
              spec = {
                  references = [{
                      patchesFrom = {
                          apiVersion = "v1"
                          kind = "Secret"
                          name = "{}-app".format(_name)
                          namespace = _namespace
                          fieldPath = "data.password"
                      }
                      toFieldPath = "data.password"
                  }]
                  forProvider.manifest = {
                      apiVersion = "v1"
                      kind = "Secret"
                      metadata = {
                          name = _name
                          namespace = _namespace
                      }
                      data = {
                          port = "NTQzMg=="
                          username = "YXBw"
                      }
                      stringData.endpoint = "{}-rw".format(_name)
                  }
                  providerConfigRef.name = _name + "-sql"
              }
          # }, {
          #     **oxr
          #     if "cluster" in ocds:
          #         status.address = ocds["cluster"].Resource.status.atProvider.serviceHost
          }]

          items = _items
  - step: common
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          schema providerConfig:
              _apiVersion: str
              _suffix: str
              apiVersion = _apiVersion
              kind = "ProviderConfig"
              metadata = {
                  name = _name + "-sql"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = _name + "-provider-config-" + _suffix
                  }
              }
              spec = {
                  credentials.source = "InjectedIdentity"
              }

          _items = [
              providerConfig {
                  _apiVersion = "kubernetes.crossplane.io/v1alpha1"
                  _suffix = "kubernetes"
          }, {
              apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
              kind = "ProviderConfig"
              metadata = {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-config"
                      "crossplane.io/external-name" = "default"
                  }
              }
              spec = {
                  credentials = {
                    source = "PostgreSQLConnectionSecret"
                    connectionSecretRef = {
                      name = _name
                      namespace = _namespace
                    }
                  }
                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                      defaultDatabase = "defaultdb"
                  sslMode = "require"
              }
          }]

          if oxr.spec?.databases:
              _items += [{
                  apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
                  kind = "Database"
                  metadata = {
                      name = _name + "-" + _database
                      annotations = {
                          "crossplane.io/external-name" = _database
                          "krm.kcl.dev/composition-resource-name" = _name + "-" + _database
                      }
                  }
                  spec = {
                      providerConfigRef.name = _name
                      forProvider = {}
                      deletionPolicy = "Orphan"
                  }
              } for _database in oxr.spec.databases ]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pullRootPasswordKey:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name + "-password"
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull"
                      }
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = oxr.spec.secrets.pullRootPasswordKey
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name + "-password"
                      }
                  }
              }]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pushToStore:
              _endpoint = """\
          {
            "endpoint": "{{ .endpoint }}",
            "port": "{{ .port }}",
            "username": "{{ .username }}",
            "password": "{{ .password }}",
            """
              _conns = [ "\"conn-{}\": \"host=[[ .endpoint ]] user=[[ .username ]] password=[[ .password ]] port=[[ .port ]] connect_timeout=10 database={}\"".format(_db, _db).replace("[[", "{{").replace("]]", "}}") for _db in oxr.spec.databases ]
              _endpoint += ",\n  ".join(_conns)
              _endpoint += """
          }
          """
              _items += [{
                  apiVersion = "external-secrets.io/v1alpha1"
                  kind = "PushSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-push-store"
                      }
                  }
                  spec = {
                      refreshInterval = "1h"
                      secretStoreRefs = [{
                          name = oxr.spec.secrets.storeName
                          kind = "ClusterSecretStore"
                      }]
                      selector.secret.name = _name
                      template.data.endpoint = _endpoint
                      data = [{
                          match = {
                              secretKey = "endpoint"
                              remoteRef.remoteKey = _name
                          }
                      }]
                      deletionPolicy = "Delete"
                  }
              }]

          if oxr.spec.schemas:
              _items += [{
                  apiVersion = "db.atlasgo.io/v1alpha1"
                  kind = "AtlasSchema"
                  metadata = {
                      name = _name + "-" + _schema.database
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-schema-" + _schema.database
                      }
                  }
                  spec = {
                      credentials = {
                          scheme = "postgres"
                          hostFrom.secretKeyRef = {
                              key = "endpoint"
                              name = _name
                          }
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                              port = 11569
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider != "upcloud":
                              port = 5432
                          userFrom.secretKeyRef = {
                              key = "username"
                              name = _name
                          }
                          passwordFrom.secretKeyRef = {
                              key = "password"
                              name = _name
                          }
                          database = _schema.database
                          parameters.sslmode = "require"
                      }
                      schema.sql = _schema.sql
                  }
              } for _schema in oxr.spec.schemas ]

          if oxr.spec.secrets?.pullToCluster:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull-cluster"
                      }
                      namespace = oxr.spec.secrets.pullToClusterNamespace
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = _name
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name
                      }
                  }
              }]

          items = _items
  - step: statuses
    functionRef:
      name: crossplane-contrib-function-status-transformer
    input:
      apiVersion: function-status-transformer.fn.crossplane.io/v1beta1
      kind: StatusTransformation
      statusConditionHooks:
      - matchers:
        - resources:
          - name: network
          conditions:
          - type: Synced
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'True'
            message: So far so good
      - matchers:
        - resources:
          - name: network
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: (.*)cannot get referenced ProviderConfig(.*)
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: ProviderConfig is missing. Contact service owner.
      - matchers:
        - resources:
          - name: network
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: '(.*)Invalid value for region: (?P<Region>.*)., invalid(.*)'
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: Selected region {{ .Region }} is not available. Double check the `spec.region` value.
  - step: automatically-detect-ready-composed-resources
    functionRef:
      name: crossplane-contrib-function-auto-ready
  writeConnectionSecretsToNamespace: crossplane-system
---
apiVersion: apiextensions.crossplane.io/v1
kind: Composition
metadata:
  labels:
    db: postgresql
    provider: upcloud
  name: upcloud-postgresql
spec:
  compositeTypeRef:
    apiVersion: devopstoolkit.live/v1beta1
    kind: SQL
  mode: Pipeline
  pipeline:
  - step: main
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr
          ocds = option("params").ocds

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          _region = "us-nyc1"
          if oxr.spec?.region:
              _region = oxr.spec.region
          _address = "10.0.0.0/24"
          if oxr.spec?.upcloud?.networkAddress:
              _address = oxr.spec.upcloud.networkAddress

          _metadata = lambda resourceName: str -> any {
              {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/composition-resource-name" = resourceName
                  }
              }
          }

          _items = [{
              apiVersion = "network.upcloud.com/v1alpha1"
              kind = "Router"
              metadata = _metadata("router")
              spec = {
                  forProvider = {
                      labels = {}
                      name = _name
                      staticRoute: []
                  }
              }
          }, {
              apiVersion = "network.upcloud.com/v1alpha1"
              kind = "Network"
              metadata = _metadata("network")
              spec.forProvider = {
                  ipNetwork = [{
                      address = _address
                      dhcp = True
                      dhcpDefaultRoute = False
                      family = "IPv4"
                  }]
                  name = _name
                  routerSelector.matchControllerRef = True
                  zone = _region
              }
          }, {
              apiVersion = "database.upcloud.com/v1alpha1"
              kind = "ManagedDatabasePostgresql"
              metadata = _metadata("manageddatabasepostgresql")
              spec = {
                  forProvider = {
                      name = _name
                      network = [{
                          family = "IPv4"
                          name = _name
                          type = "private"
                          uuidSelector.matchControllerRef = True
                      }]
                      if oxr.spec.size == "small":
                          plan = "1x1xCPU-2GB-25GB"
                      elif oxr.spec.size == "medium":
                          plan = "2x6xCPU-16GB-100GB"
                      else:
                          plan = "2x16xCPU-64GB-1000GB"
                      title: _name
                      zone: _region
                      properties = [{
                          publicAccess = True
                          ipFilter = ["0.0.0.0/0"]
                      }]
                  }
                  writeConnectionSecretToRef = {
                      name = _name + "-password"
                      namespace = _namespace
                  }
              }
          # }, {
          #     apiVersion = "meta.krm.kcl.dev/v1alpha1"
          #     kind = "ExtraResources"
          #     requirements = {
          #         secret = {
          #             apiVersion = "v1"
          #             kind = "Foo"
          #             matchName = _name + "-password"
          #             namespace = _namespace
          #         }
          #     }
          }, {
              apiVersion = "kubernetes.crossplane.io/v1alpha2"
              kind = "Object"
              metadata = {
                  name = _name + "-secret"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-secret"
                  }
              }
              spec = {
                  references = [{
                      patchesFrom = {
                          apiVersion = "v1"
                          kind = "Secret"
                          name = _name + "-password"
                          namespace = _namespace
                          fieldPath = "data[attribute.service_password]"
                      }
                      toFieldPath = "data.password"
                  }]
                  forProvider.manifest = {
                      apiVersion = "v1"
                      kind = "Secret"
                      metadata = {
                          name = _name
                          namespace = _namespace
                      }
                      data = {
                          port = "MTE1Njk="
                          username = "dXBhZG1pbg=="
                      }
                      if "manageddatabasepostgresql" in ocds and ocds["manageddatabasepostgresql"]?.Resource?.status?.atProvider?.serviceHost:
                          stringData.endpoint = "public-" + ocds["manageddatabasepostgresql"].Resource.status.atProvider.serviceHost
                  }
                  providerConfigRef.name = _name + "-sql"
              }
          }, {
              **oxr
              if "manageddatabasepostgresql" in ocds:
                  status.address = ocds["manageddatabasepostgresql"].Resource.status.atProvider.serviceHost
          }]

          items = _items
  - step: common
    functionRef:
      name: crossplane-contrib-function-kcl
    input:
      apiVersion: krm.kcl.dev/v1alpha1
      kind: KCLRun
      spec:
        dependencies: models = { git = "https://github.com/vfarcic/crossplane-sql", commit = "8bc4027057a9a9f47bb80132121c8b9130feb809" }
        source: |
          oxr = option("params").oxr

          _name = oxr.metadata.name
          _namespace = oxr.metadata.namespace
          schema providerConfig:
              _apiVersion: str
              _suffix: str
              apiVersion = _apiVersion
              kind = "ProviderConfig"
              metadata = {
                  name = _name + "-sql"
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = _name + "-provider-config-" + _suffix
                  }
              }
              spec = {
                  credentials.source = "InjectedIdentity"
              }

          _items = [
              providerConfig {
                  _apiVersion = "kubernetes.crossplane.io/v1alpha1"
                  _suffix = "kubernetes"
          }, {
              apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
              kind = "ProviderConfig"
              metadata = {
                  name = _name
                  annotations = {
                      "krm.kcl.dev/ready": "True"
                      "krm.kcl.dev/composition-resource-name" = "sql-config"
                      "crossplane.io/external-name" = "default"
                  }
              }
              spec = {
                  credentials = {
                    source = "PostgreSQLConnectionSecret"
                    connectionSecretRef = {
                      name = _name
                      namespace = _namespace
                    }
                  }
                  if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                      defaultDatabase = "defaultdb"
                  sslMode = "require"
              }
          }]

          if oxr.spec?.databases:
              _items += [{
                  apiVersion = "postgresql.sql.crossplane.io/v1alpha1"
                  kind = "Database"
                  metadata = {
                      name = _name + "-" + _database
                      annotations = {
                          "crossplane.io/external-name" = _database
                          "krm.kcl.dev/composition-resource-name" = _name + "-" + _database
                      }
                  }
                  spec = {
                      providerConfigRef.name = _name
                      forProvider = {}
                      deletionPolicy = "Orphan"
                  }
              } for _database in oxr.spec.databases ]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pullRootPasswordKey:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name + "-password"
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull"
                      }
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = oxr.spec.secrets.pullRootPasswordKey
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name + "-password"
                      }
                  }
              }]

          if oxr.spec.secrets?.storeName and oxr.spec.secrets?.pushToStore:
              _endpoint = """\
          {
            "endpoint": "{{ .endpoint }}",
            "port": "{{ .port }}",
            "username": "{{ .username }}",
            "password": "{{ .password }}",
            """
              _conns = [ "\"conn-{}\": \"host=[[ .endpoint ]] user=[[ .username ]] password=[[ .password ]] port=[[ .port ]] connect_timeout=10 database={}\"".format(_db, _db).replace("[[", "{{").replace("]]", "}}") for _db in oxr.spec.databases ]
              _endpoint += ",\n  ".join(_conns)
              _endpoint += """
          }
          """
              _items += [{
                  apiVersion = "external-secrets.io/v1alpha1"
                  kind = "PushSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-push-store"
                      }
                  }
                  spec = {
                      refreshInterval = "1h"
                      secretStoreRefs = [{
                          name = oxr.spec.secrets.storeName
                          kind = "ClusterSecretStore"
                      }]
                      selector.secret.name = _name
                      template.data.endpoint = _endpoint
                      data = [{
                          match = {
                              secretKey = "endpoint"
                              remoteRef.remoteKey = _name
                          }
                      }]
                      deletionPolicy = "Delete"
                  }
              }]

          if oxr.spec.schemas:
              _items += [{
                  apiVersion = "db.atlasgo.io/v1alpha1"
                  kind = "AtlasSchema"
                  metadata = {
                      name = _name + "-" + _schema.database
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-schema-" + _schema.database
                      }
                  }
                  spec = {
                      credentials = {
                          scheme = "postgres"
                          hostFrom.secretKeyRef = {
                              key = "endpoint"
                              name = _name
                          }
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider == "upcloud":
                              port = 11569
                          if oxr.spec.crossplane.compositionSelector.matchLabels.provider != "upcloud":
                              port = 5432
                          userFrom.secretKeyRef = {
                              key = "username"
                              name = _name
                          }
                          passwordFrom.secretKeyRef = {
                              key = "password"
                              name = _name
                          }
                          database = _schema.database
                          parameters.sslmode = "require"
                      }
                      schema.sql = _schema.sql
                  }
              } for _schema in oxr.spec.schemas ]

          if oxr.spec.secrets?.pullToCluster:
              _items += [{
                  apiVersion = "external-secrets.io/v1"
                  kind = "ExternalSecret"
                  metadata = {
                      name = _name
                      annotations = {
                          "krm.kcl.dev/ready" = "True"
                          "krm.kcl.dev/composition-resource-name" = _name + "-secret-pull-cluster"
                      }
                      namespace = oxr.spec.secrets.pullToClusterNamespace
                  }
                  spec = {
                      dataFrom = [{
                          extract = {
                              conversionStrategy = "Default"
                              decodingStrategy = "None"
                              key = _name
                              metadataPolicy = "None"
                          }
                      }]
                      refreshInterval = "1h"
                      secretStoreRef = {
                          kind = "ClusterSecretStore"
                          name = oxr.spec.secrets.storeName
                      }
                      target = {
                          creationPolicy = "Owner"
                          deletionPolicy = "Retain"
                          name = _name
                      }
                  }
              }]

          items = _items
  - step: statuses
    functionRef:
      name: crossplane-contrib-function-status-transformer
    input:
      apiVersion: function-status-transformer.fn.crossplane.io/v1beta1
      kind: StatusTransformation
      statusConditionHooks:
      - matchers:
        - resources:
          - name: cluster
          conditions:
          - type: Synced
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'True'
            message: So far so good
      - matchers:
        - resources:
          - name: cluster
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: (.*)cannot get referenced ProviderConfig(.*)
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: ProviderConfig is missing. Contact service owner.
      - matchers:
        - resources:
          - name: cluster
          conditions:
          - type: Synced
            status: 'False'
            reason: ReconcileError
            message: '(.*)Invalid value for region: (?P<Region>.*)., invalid(.*)'
        setConditions:
        - target: CompositeAndClaim
          force: true
          condition:
            type: Developer
            status: 'False'
            reason: FailedToConnect
            message: Selected region {{ .Region }} is not available. Double check the `spec.region` value.
  - step: automatically-detect-ready-composed-resources
    functionRef:
      name: crossplane-contrib-function-auto-ready
  writeConnectionSecretsToNamespace: crossplane-system
